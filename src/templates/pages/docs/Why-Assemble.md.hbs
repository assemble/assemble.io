---
title: Why Assemble?
published: false
section: getting started
---

> As a _site generator_, Assemble was designed to do orders of magnitude more than just "render templates". However, if all you need is to generated templates, it can't get much easier than Assemble. 

* Easily deploy to gh-pages
* Grunt.js based, so you can use Assemble to build your site, and fill in any gaps in your build process with other grunt plugins.
* `npm install assemble` and be running in a couple of minutes.

If you haven't tried out assemble, give it a shot. 

## FAQs

A few reasons to try assemble

If you would like something more concrete, I just started putting these example projects together to demonstrate what assemble can do: [assemble-examples][2]. Here are a few reasons to try assemble:

* Assemble let's you use any combination of the following as data sources for your templates: [JSON][] files, [YAML][] files, [YAML front-matter][yaml-front-matter], and even custom properties in the `assemble` task or target options.

* Methods to the [assemble object][3] can be used for creating custom **build "steps"**

* Built-in variables and helpers for generating sitemaps, collections of pages, categories, tags, archives, or even custom collections and collection items. 

* Assemble's helper library is pretty awesome, which we externalized and generalized to a project called [helper-lib][4], which now includes somewhere around 100-110 helpers. You will get a better sense of the "unique" helpers we provide by checking out the code in helper-lib (either the coffeescript source files or generated javascript in the lib folder), or the example projects.

* You can build "collections" of pages using the src-dest pairings, with as many targets as you need. 

* Layouts and partials can optionally be used.

* The way assemble handles templates and data/metadata is pretty powerful. You can, for instance, create a big library of partials, then create a bunch of `[name].json` or YAML data files that have the same names as the partials. Then just add the paths to the data files and partials in the assemble task and/or target options, and when you run `grunt assemble` partials that are used anywhere in your pages will automatically be registered, and context will be appropriately applied. 

* let's say you're building a website/webapp that includes a bunch of UI components, like Bootstrap's LESS components. you could use assemble to not only build your pages, but also your documentation - and part of the live application - from the same source files. In a nutshell, in the assemble task you would set up one or more targets for building "static pages", then for your docs you could create another target where you could either build each partial (component) into a page of its own, or multiple partials per page, or both - or however you want to do it. 

* Assemble wants to be the best task for generating pages from templates and data. Being based on Grunt.js means that Assemble is just another plugin. At the end of the day, pages are just a part of your project, so you can surround Assemble with any other plugins you need from the Grunt.js community, or custom plugins, to fill in whatever gaps still exist in your build process. In other words, we have no need or motivation to try to bundle in everything you can think of. So no need for this: "Assemble concats, minifies, shreds, dices, slices and does your taxes". You can use whatever plugin you think is best to accomplish each one of those tasks. 

* [Jon Schlinkert](https://github.com/jonschlinkert) - assemble co-creator: "I'm on the core team for [Less.js](https://github.com/cloudhead/less.js), and we will be using Assemble to maintain the new [lesscss.org](http://lesscss.org) website, which means that Assemble is more likely to continue being supported 

* Assemble is open source. We're just a couple of nerds that decided to do this on our own time, completely for fun, because we absolutely love doing it. 
* We use Assemble on our own projects every day.


## Guiding philosophies 
There is a lot more functionality that needs to be documented, but IMHO the most important thing about assemble is how we make decisions on functionality and features. 

1. Leverage native [Grunt.js](http://gruntjs.com) functionality wherever possible, and whenever practical
2. Try to provide as much flexibility as possible, so that Assemble is not hard-coded to a specific use case, as we found with other site builders. However, we need to have conventions for things that can be generalize, such as the various means of accessing data, exposing options and methods and so on. I'm not a big fan of this kind of convention: "you can use as many includes (partials) as you want, long as they're all in a special folder called 'includes', and with an underscore in front of it just to make absolutely sure that we know it's for includes, so call it '_includes'". Being built on top of Grunt gets us around these kinds of silly restrictions pretty easily. You can stick partials in as many directories as you want, just tell Assemble where they are in the task or targets. Same goes for data, pages, layouts, and even custom helpers - which are just like teh "filters" used in Jekyll.
3. Use it, use it, use it. Try to break it as often as possible. We use it constantly, and on projects that matter to us, so we're always motivated to fix it. This works.


## Use cases

* "I just want to generate templates, I don't need a _site generator_"
* "I need a personal blog"
* "I need to build the gh-pages for my GitHub project"


[1]: http://github.com/assemble/assemble
[2]: https://github.com/assemble/assemble-examples
[3]: https://github.com/assemble/assemble/blob/master/docs/docs-methods.md
[4]: https://github.com/assemble/helper-lib